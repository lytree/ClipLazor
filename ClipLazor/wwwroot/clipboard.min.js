"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var ClipLazor;
(function (ClipLazor) {
    class Clipboard {
        constructor() {
            // Check for Chromium-based browser
            const userAgentData = navigator.userAgentData;
            this.isChromium = !!userAgentData && userAgentData.brands.some(data => data.brand == 'Chromium');
        }
        /**
         * Checks if the Clipboard API is supported in the current browser.
         *
         * @returns {boolean} `true` if the Clipboard API is supported, otherwise `false`.
         */
        isClipboardSupported() {
            return !!navigator.clipboard;
        }
        /**
         * Checks if the browser has permission to write to the clipboard.
         * @see https://developer.mozilla.org/en-US/docs/Web/API/Clipboard_API#security_considerations
         *
         *
         * @param {PermissionName} command - The permission name to check (e.g., 'clipboard-write').
         * @returns {Promise<boolean>} A Promise that resolves to `true` if the permission is granted, otherwise `false`.
         */
        hasClipboardPermission(command) {
            return __awaiter(this, void 0, void 0, function* () {
                if (this.isChromium) {
                    try {
                        const permissionStatus = yield navigator.permissions.query({ name: command });
                        return permissionStatus.state === 'granted';
                    }
                    catch (error) {
                        console.error(`Error checking ${command} permission:`, error);
                        return false;
                    }
                }
                return true;
            });
        }
        /**
         * Copies the given text to the clipboard.
         *
         * @param {string} text - The text to be copied to the clipboard.
         * @returns {Promise<boolean>} A Promise that resolves to `true` if the copy operation is successful, otherwise `false`.
         */
        copyToClipboard(text) {
            return __awaiter(this, void 0, void 0, function* () {
                if (this.isClipboardSupported()) {
                    try {
                        yield navigator.clipboard.writeText(text);
                        return true;
                    }
                    catch (error) {
                        console.error("Error copying to clipboard:", error);
                        return false;
                    }
                }
                else {
                    this.commandCopy(text);
                    return true;
                }
            });
        }
        /**
         * Reads text data from the clipboard.
         *
         * @returns {Promise<string | null>} A Promise that resolves to the copied text if successful, otherwise `null`.
         */
        pasteFromClipboard() {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const text = yield navigator.clipboard.readText();
                    return text;
                }
                catch (error) {
                    console.error("Error pasting from clipboard:", error);
                    return null;
                }
            });
        }
        /**
         * Copies binary data (e.g., Uint8Array) to the clipboard with a specified MIME type.
         *
         * @param {Uint8Array} data - The binary data to be copied to the clipboard.
         * @param {string} mimeType - The MIME type of the data.
         * @returns {Promise<boolean>} A Promise that resolves to `true` if the copy operation is successful, otherwise `false`.
         */
        copyDataToClipboard(data, mimeType) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const blob = new Blob([data], { type: mimeType });
                    yield navigator.clipboard.write([new ClipboardItem({ [mimeType]: blob })]);
                    return true;
                }
                catch (error) {
                    console.error("Error copying data to clipboard:", error);
                    return false;
                }
            });
        }
        /**
         * Reads binary data (e.g., Uint8Array) from the clipboard with a specified MIME type.
         *
         * @param {string} mimeType - The MIME type of the data to read.
         * @returns {Promise<Uint8Array | null>} A Promise that resolves to the binary data if found, otherwise `null`.
         */
        readDataFromClipboard(mimeType) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const clipboardItems = yield navigator.clipboard.read();
                    for (const item of clipboardItems) {
                        for (const type of item.types) {
                            if (type === mimeType) {
                                const blob = yield item.getType(type);
                                if (blob instanceof Blob) {
                                    const arrayBuffer = yield blob.arrayBuffer();
                                    return new Uint8Array(arrayBuffer);
                                }
                            }
                        }
                    }
                    return null; // Data with the specified mimeType not found in clipboard
                }
                catch (error) {
                    console.error("Error reading data from clipboard:", error);
                    return null;
                }
            });
        }
        /**
         * Attaches a clipboard action (copy or cut) to a target HTML element.
         *
         * @param targetId - The ID of the target HTML element on which the clipboard action is to be performed.
         * @param action - The clipboard action to perform, either 'copy' or 'cut'.
         * @param dotNet - A .NET object reference used to invoke callback methods in Blazor.
         * @returns A promise that resolves when the clipboard action and associated callback invocation are complete.
         */
        attachClipboardAction(targetId, action, dotNet) {
            return __awaiter(this, void 0, void 0, function* () {
                const targetElement = document.getElementById(targetId);
                if (!targetElement) {
                    yield dotNet.invokeMethodAsync('OnTextActionCallback', "", action, false);
                    return;
                }
                if (!this.isTextContentElement(targetElement)) {
                    yield dotNet.invokeMethodAsync('OnTextActionCallback', "", action, false);
                    return;
                }
                const value = this.getElementContent(targetElement);
                const success = yield this.copyToClipboard(value);
                if (success && action === 'cut') {
                    this.clearElementContent(targetElement);
                }
                yield dotNet.invokeMethodAsync('OnTextActionCallback', value, action, true);
            });
        }
        getElementContent(element) {
            if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {
                return element.value;
            }
            else {
                return element.innerText;
            }
        }
        clearElementContent(element) {
            if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {
                element.value = '';
            }
            else {
                element.innerText = '';
            }
        }
        isTextContentElement(element) {
            return (element instanceof HTMLInputElement ||
                element instanceof HTMLTextAreaElement ||
                element.isContentEditable || // For editable divs
                element instanceof HTMLHeadingElement ||
                element instanceof HTMLParagraphElement ||
                element instanceof HTMLSpanElement);
        }
        dataURLToUint8Array(dataUrl) {
            const base64 = dataUrl.split(',')[1];
            const binary = atob(base64);
            const length = binary.length;
            const buffer = new Uint8Array(length);
            for (let i = 0; i < length; i++) {
                buffer[i] = binary.charCodeAt(i);
            }
            return buffer;
        }
        commandCopy(value) {
            const ta = document.createElement('textarea');
            ta.value = value !== null && value !== void 0 ? value : '';
            ta.style.position = 'absolute';
            ta.style.opacity = '0';
            document.body.appendChild(ta);
            ta.select();
            document.execCommand('copy');
            ta.remove();
        }
    }
    function Load() {
        window['clipLazor'] = new Clipboard();
    }
    ClipLazor.Load = Load;
})(ClipLazor || (ClipLazor = {}));
ClipLazor.Load();
